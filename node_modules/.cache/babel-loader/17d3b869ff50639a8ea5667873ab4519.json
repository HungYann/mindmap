{"ast":null,"code":"import md5 from 'md5';\nimport * as refer from '../statics/refer';\n\nconst getLayerAndText = (line, format) => {\n  let layer, text;\n\n  switch (format) {\n    case 'MD':\n      {\n        if (line.match(/^#{1,6} /)) {\n          layer = line.match(/^#{1,6} /)[0].length - 2;\n          text = line.replace(/^#{1,6} /, '');\n        } else if (line.match(/^\\s*[-*] /)) {\n          layer = line.match(/^\\s*[-*] /)[0].length + 4;\n          text = line.replace(/^\\s*[-*] /, '');\n        }\n\n        return {\n          layer,\n          text\n        };\n      }\n\n    case 'TXT':\n      {\n        layer = line.match(/^\\s*/)[0].length;\n        text = line.replace(/^\\s*/, '');\n        return {\n          layer,\n          text\n        };\n      }\n\n    default:\n      return {\n        layer,\n        text\n      };\n  }\n};\n\nconst buildNodeFromText = (data_array, format, cur_layer, cur_text = '') => {\n  if (data_array.length === 0 && cur_layer === -1) {\n    return;\n  }\n\n  if (cur_layer === -1) {\n    const root_data = getLayerAndText(data_array.shift(), format);\n    cur_layer = root_data.layer || 0; // 一定的鲁棒性\n\n    cur_text = root_data.text || '未知数据';\n  }\n\n  const cur_node = {\n    id: cur_layer === 0 ? refer.ROOT_NODE_ID : md5('' + Date.now() + Math.random() + cur_text),\n    text: cur_text,\n    showChildren: true,\n    children: []\n  };\n\n  while (data_array.length > 0) {\n    const _getLayerAndText = getLayerAndText(data_array[0], format),\n          layer = _getLayerAndText.layer,\n          text = _getLayerAndText.text;\n\n    if (layer <= cur_layer) {\n      break;\n    }\n\n    data_array.shift();\n\n    if (layer) {\n      // 排除掉无法匹配的情况\n      cur_node.children.push(buildNodeFromText(data_array, format, layer, text));\n    }\n  }\n\n  return cur_node;\n};\n\nconst copyNodeData = (format, target_node, source_node, is_root_node) => {\n  switch (format) {\n    case 'KM':\n      target_node.id = is_root_node ? refer.ROOT_NODE_ID : source_node.data.id;\n      target_node.text = source_node.data.text;\n      target_node.showChildren = source_node.data.expandState !== 'collapse';\n      target_node.children = source_node.children.map(child => copyNodeData(format, {}, child));\n      return target_node;\n\n    default:\n      return;\n  }\n};\n\nconst buildNodeFromJSON = (json, format) => {\n  switch (format) {\n    case 'RMF':\n      return JSON.parse(json);\n\n    case 'KM':\n      {\n        let km_mindmap = JSON.parse(json);\n        return copyNodeData(format, {}, km_mindmap.root, true);\n      }\n\n    default:\n      return;\n  }\n};\n\nexport default ((import_data, format) => {\n  let mindmap;\n\n  switch (format) {\n    case 'MD':\n    case 'TXT':\n      const data_array = import_data.split('\\n').filter(line => line);\n      mindmap = buildNodeFromText(data_array, format, -1);\n      break;\n\n    default:\n      mindmap = buildNodeFromJSON(import_data, format);\n      break;\n  }\n\n  return mindmap;\n});","map":{"version":3,"sources":["/Users/liuhongyang/Desktop/RMind-develop/src/methods/mindmapParser.js"],"names":["md5","refer","getLayerAndText","line","format","layer","text","match","length","replace","buildNodeFromText","data_array","cur_layer","cur_text","root_data","shift","cur_node","id","ROOT_NODE_ID","Date","now","Math","random","showChildren","children","push","copyNodeData","target_node","source_node","is_root_node","data","expandState","map","child","buildNodeFromJSON","json","JSON","parse","km_mindmap","root","import_data","mindmap","split","filter"],"mappings":"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","sourcesContent":["import md5 from 'md5';\nimport * as refer from '../statics/refer';\n\nconst getLayerAndText = (line, format) => {\n    let layer, text;\n    switch (format) {\n        case 'MD': {\n            if (line.match(/^#{1,6} /)) {\n                layer = line.match(/^#{1,6} /)[0].length - 2;\n                text = line.replace(/^#{1,6} /, '');\n            } else if (line.match(/^\\s*[-*] /)) {\n                layer = line.match(/^\\s*[-*] /)[0].length + 4;\n                text = line.replace(/^\\s*[-*] /, '');\n            }\n            return {layer, text};\n        }\n        case 'TXT': {\n            layer = line.match(/^\\s*/)[0].length;\n            text = line.replace(/^\\s*/, '');\n            return {layer, text};\n        }\n        default:\n            return {layer, text};\n    }\n};\n\nconst buildNodeFromText = (data_array, format, cur_layer, cur_text = '') => {\n    if (data_array.length === 0 && cur_layer === -1) {\n        return;\n    }\n    if (cur_layer === -1) {\n        const root_data = getLayerAndText(data_array.shift(), format);\n        cur_layer = root_data.layer || 0; // 一定的鲁棒性\n        cur_text = root_data.text || '未知数据';\n    }\n    const cur_node = {\n        id: cur_layer === 0 ? refer.ROOT_NODE_ID : md5('' + Date.now() + Math.random() + cur_text),\n        text: cur_text,\n        showChildren: true,\n        children: []\n    };\n    while (data_array.length > 0) {\n        const {layer, text} = getLayerAndText(data_array[0], format);\n        if (layer <= cur_layer) {\n            break;\n        }\n        data_array.shift();\n        if (layer) { // 排除掉无法匹配的情况\n            cur_node.children.push(buildNodeFromText(data_array, format, layer, text));\n        }\n    }\n    return cur_node;\n};\n\nconst copyNodeData = (format, target_node, source_node, is_root_node) => {\n    switch (format) {\n        case 'KM':\n            target_node.id = is_root_node ? refer.ROOT_NODE_ID : source_node.data.id;\n            target_node.text = source_node.data.text;\n            target_node.showChildren = source_node.data.expandState !== 'collapse';\n            target_node.children = source_node.children.map(child => copyNodeData(format, {}, child));\n            return target_node;\n        default:\n            return;\n    }\n};\n\nconst buildNodeFromJSON = (json, format) => {\n    switch (format) {\n        case 'RMF':\n            return JSON.parse(json);\n        case 'KM': {\n            let km_mindmap = JSON.parse(json);\n            return copyNodeData(format, {}, km_mindmap.root, true);\n        }\n        default:\n            return;\n    }\n};\n\nexport default (import_data, format) => {\n    let mindmap;\n    switch (format) {\n        case 'MD':\n        case 'TXT':\n            const data_array = import_data.split('\\n').filter(line => line);\n            mindmap = buildNodeFromText(data_array, format, -1);\n            break;\n        default:\n            mindmap = buildNodeFromJSON(import_data, format);\n            break;\n    }\n    return mindmap;\n}"]},"metadata":{},"sourceType":"module"}